<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>SDL-widgets, a GUI toolkit using SDL</title>
<style type="text/css">
body {
  background-color:#F0F0F0;
  font-family:Verdana,"Luxi Sans";
  font-size:11pt;
}
h1 { font-family:FreeSerif; color:#B00000; font-size:30pt; }
h2 { font-family:FreeSerif; color:#B00000; font-size:20pt;}
h3 { font-family:FreeSerif; color:#B00000; font-size:14pt; }
h4 { font-family:FreeSerif; color:#B00000; font-size:12pt; }
tt {
  font-family:"Courier New",Monospace;
  font-size:11pt;
  font-weight: bold;
}
pre {
  font-family:"Courier New",Monospace;
  font-size:11pt;
  font-weight: normal;
}
table {
  border-collapse: collapse;
  width:95%;
  font-weight:inherit;
  font-size:inherit;
  padding:10px;
}
td {
  background-color:#F7F7E0;
  border:solid thin grey;
  font-weight:inherit;
  vertical-align:top;
  padding:10px;
}
table td.bold {
  font-family:"Courier New",Monospace;
  font-weight:bold;
  font-size:11pt;
  background-color:#E0E0E0;
}
dt {
  font-family:"Courier New",Monospace;
  font-weight:bold;
  font-size:11pt;
  font-weight:bold;
}
hr { width:50%; }
</style>
</head>
<body>
<center>
<h1>SDL-widgets</h1>
<b>A GUI toolkit using the SDL libraries</b><br>
(version 1.0)<br>
Author:<br>
<img src="mail-adr.gif"><br>
Last updated: dec 2011
</center>
<p>
<h2>Introduction</h2>
SDL-widgets is a GUI toolkit using the the SDL libraries (version 1.2). It is aiming at normal applications, which implies:
a possibly complicated SDL_Surface hierarchy, where surfaces can be hidden or visible, with sliders, menus,
text areas, etc. There are provisions for threads that can communicate with the main thread via messages,
where you don't have to apply locks.
<p>
This version 1.0 is rather complete, with good support for complicated applications.
Regarding text, only ascii is supported.
There are 2 small applications
which should be useful for sound designers, called make-waves and bouncy-tune,
which might serve as examples of real applications. Also the mandatory 'Hello World' and a demo program are
present.
<p>
In the following it's supposed that you know how SDL works. Building a surface hierarchy, where surfaces
can be both hidden and updated at runtime, is not very straightforward. This is because surfaces
are blitted (copied) to each other, so if one surface is modified, then its copied version will be out of date.
Some methods are provided to cope with this issue. If these are not sufficient then you can
write your own solutions: the toolkit is written in C++ where all class variables and methods are accessable 
by the user, there are no private members.
<p>
An important feature of this toolkit is that applications are fully type-checked at compile time, 
because there are no obligatory type-casts.
The <a href="#cookbook"><b>Cookbook</b></a> chapter might be useful to get you started.
<h2>The widget classes</h2>
<table>
<tr>
<td class="bold">WinBase
<td>This is the base class for most other widgets. The most interesting variables and methods are
as follows.
<dl>
<dt>WinBase(WinBase *pw,const char *title,int x,int y,int dx,int dy,Uint32 bgcol,Id id)<dd>
  The constructor. Parameters:<br>
  <tt>pw</tt>: the parent of a widget, used to create the internal widget hierarchy.<br>
  <tt>title</tt>: to be drawn above the widget.<br>
  <tt>x, y, dx, dy</tt>: the area occupied by the widget. For some subclasses <tt>dx</tt> and/or
    <tt>dy</tt> may be 0, in this case the subclass will supply a default value.<br>
  <tt>bgcol</tt>: the background color of the widget.<br>
  <tt>id</tt>: An Id is the identification for a widget. It will be passed as a parameter to callback functions
    so the application will know where a call originated from.
  </dd>
<dt>~WinBase()<dd>
  The destructor. The widget will be removed from the list of childrens of its parent.
  If the widget has children these are also deleted. If the widget is a temporary widget
  above the other widgets, then it also will disappear correctly.</dd>
<dt>SDL_Surface *win<br>
    SDL_Surface *title<dd>
  The SDL surfaces for the widget and for its title.
<dt>WinBase *parent<br>WinBase **children<dd>
  To build the surface hierarchy. <tt>children</tt> is an array of pointers to child widgets.
<dt>Point area,<br>
    Rect tw_area,<br>
    Rect title_area<dd>
  <tt>area</tt> and <tt>title_area</tt> are relative to the parent surface,
  <tt>tw_area</tt> is relative to the top surface. The values of <tt>tw_area.w</tt> and <tt>win->w</tt> are equal,
  and also <tt>tw_area.h</tt> and <tt>win->h</tt>.</dd>
<dt>Uint32 bgcol<dd>
  Background color, can be used to clear the surface.</dd>
<dt>bool hidden<dd>
  If this has value <tt>true</tt>, then the surface still can be modified, it will not be visible however.
  Child widgets will not be visible either.</dd>
<dt>void clear(Rect *rect=0)<dd>
  Fills surface <tt>win</tt> with color <tt>bgcol</tt>. SDL_Update is <i>not</i> called.</dd>
<dt>void clear(Rect *rect,Uint32 col,bool upd)<dd>
  Idem, using color <tt>col</tt>. If <tt>upd</tt> is true, then SDL_Update is called.</dd>
<dt>void draw_raised(Rect *rect,Uint32 col,bool up)<dd>
  Clear, then draw white and grey lines at the borders of <tt>rect</tt>, suggesting a raised (if <tt>up</tt> is true) or
  sunken (if <tt>up</tt> is false) area.</dd>
<dt>void border(WinBase *child,int wid=1)<dd>
  Draw a 3D border around a child widget. The width <tt>wid</tt> can be 1, 2 or 3.
  The title of the child widget is shifted upwards, so it does not overlap the drawn border.</dd>
<dt>void hide()<dd>
  Sets the <tt>hidden</tt> variable to <tt>true</tt>. The widget's area in the top surface will be replaced
  with the background color. When get_events() is not started yet (<tt>sdl_running</tt> = false)
  then calling this method is not needed, setting variable <tt>hidden</tt> to true will suffice.</dd>
<dt>void show()<dd>
  Sets the <tt>hidden</tt> variable to <tt>false</tt>, then blits the widget and its title to the top surface and updates it.
  <i>Not</i> recursive.</dd>
<dt>void keep_on_top()<dd>
  Keeps this widget on top of other widgets. Useable for widgets that can cover other widgets. 
  If not needed anymore it can be deleted, or you can use <tt>hide()</tt> and later <tt>show()</tt>.<br>
  This method does 2 things: it sets up the necessary data structures, then it connects the widget
  to the top window. Therefore the widget should have been instantiated with parameter <tt>pw</tt> 
  (the parent widget) set to 0.<br>
  A widget of class BgrWin can be made movable with the mouse. In this case the mouse-parameter callbacks
  should be <tt>mwin::down</tt>, <tt>mwin::move</tt>, <tt>mwin::up</tt>.</dd>
<dt>void draw_blit_recur()<dd>
  The widget is drawn, then its children are drawn and blitted recursivily to its surface, then the surface
  is blitted to its parent. Also the titles of the children are blitted.<br>
  This method is called once from the top level, as the first statement of <tt>get_events()</tt>.
  It can be used later also, e.g. after several children of a widget have been modified.</dd>
<dt>void upd(Rect *rect)<dd>
  Calls SDL_UpdateRects(topwindow->win,1,rect), however if the alert window or other keep_on_top'd widgets 
  are covering the rect, then these will stay neatly on top.<br>
  This method can be called by the top window, or by a widget whose parent is the top window.</dd>
<dt>void blit_upd(Rect *rect=0)<dd>
  This method blits (part of) a surface to all its parents.
  If <tt>sdl_running</tt> is false, this method does nothing.
  If the surface or one of its parents is not hidden, then the screen is updated.
  If <tt>rect</tt> is zero then the whole surface is blitted and updated.
<dt>void draw_blit_upd()<dd>
  Calls draw(), then blit_upd().
  If <tt>sdl_running</tt> is false, this method does nothing, so it is useful after
  the widget has been modified.</dd>
<dt>void set_title(const char* new_t,bool upd)<dd>
  To modify the title. If upd is true, then the new title will be blitted and shown.</dd>
<dt>virtual void draw()=0<dd>
  Each subclass has an implementation for this virtual method.</dd>
</dl>
NB! You do not need to use these drawing and blitting methods in your program. E.g. if a picture never will
be hidden, then you can draw it directly to the top window, then call SDL_UpdateRects().</dd>
</tr>

<tr>
<td class="bold">Id
<td>The use of this class (identification for callback functions) has been treated above.
<dl>
  <dt>Id(int id1)<br>
      Id(int id1,int id2)<dd>
    The constructors. Notice that in function parameter lists you do not have to write e.g. <tt>Id('abcd')</tt>,
    because <tt>'abcd'</tt> is sufficient. This is one of the conveniences provided
    by the C++ language.</dd>
  <dt>int id1<br>
      int id2<dd>
    <tt>id1</tt> usually is of the form <tt>'abcd'</tt> or <tt>ABCD</tt>, where ABCD is an enum or has been #define'd.
    <tt>id2</tt> could specify e.g. an array index.</dd>
</dl>
</tr>

<tr>
<td class="bold">Label
<td>This class is used for labeling widgets. A Label has 3 variables and several constructors.
<dl>
  <dt>Label(const char* txt)<br>
      Label(void (*draw)(SDL_Surface *win,int nr,int y_off))<br>
      Label(const char *txt,void (*draw)(SDL_Surface *win,int nr,int y_off))<dd>
  When a Label is drawn, then usually a fixed string <tt>txt</tt> is drawn (if it is non-zero),
  and/or function <tt>draw</tt> is called (if it is non-zero).
  <dt>void (*draw_cmd)(SDL_Surface *win,int nr,int y_off)<dd>
    If non-zero, this function is called when the widget is drawn.
    <tt>nr</tt> can be the button number in case of radio buttons, or the value of <tt>id.id2</tt>
    for other widgets. <tt>y_off</tt> can get a value in case of radio buttons,
    if they are shifted by a scrollbar.</dd>
  <dt>const char *str<dd>
    A pointer to the title string</dd>
  <dt>RenderText *render_t<dd>
    Specifies the font, default: <tt>draw_ttf</tt>.</dd>
  <dt>void draw(SDL_Surface *win,int nr,Point pnt)<dd>
    To draw <tt>str</tt> as text, and to call <tt>draw_cmd(win,nr,pnt.y)</tt>.</dd>
</dl>
</tr>

<tr>
<td class="bold">Style
<td>This class is used to control the appearance of widgets.
<dl>
  <dt>Style(int st)<br>
      Style(int st,Uint32 param)<br>
      Style(int st,Uint32 param,int param2)<dd>
    The constructors.</dd>
  <dt>const int st<dd>
    This integer is for specifying the specific appearance of a widget.</dd>
  <dt>Uint32 param<dd>
    Can specify a color.</dd>
  <dt>int param2<dd>
    Can specify a number to be used by the drawing routine of a widget.</dd>
</dl>
</tr>

<tr>
<td class="bold">TopWin:WinBase
<td>The topwindow. The constructor:
<dl>
<dt>TopWin(Rect rect,const char* title,<br>
  &emsp;Uint32 init_flag,Uint32 video_flag,void (*draw)(),void (*set_icon)())<dd>
  <tt>init_flag</tt> is passed to SDL_Init().<br>
  <tt>video_flag</tt> is passed to SDL_SetVideoMode(). It may be 0, then SDL_SWSURFACE will be passed.<br>
  The function <tt>set_icon</tt> will be called (if not 0) after SDL_init() and before SDL_SetVideoMode().
  It will be used to set the icon for your application.</dd>
</tr>

<tr>
<td class="bold">BgrWin:WinBase
<td>This is a background widget and also a canvas for drawing. The constructor, variables and methods:
<dl>
<dt>BgrWin(WinBase *pw,Rect rect,const char* title,<br>
  &emsp; void (*display_cmd)(BgrWin*),void (*down_cmd)(BgrWin*,int,int,int),<br>
  &emsp; void (*moved_cmd)(BgrWin*,int,int,int),void (*up_cmd)(BgrWin*,int,int,int),<br>
  &emsp; Uint32 bgcol,Id id=0)<dd>
  <tt>display_cmd()</tt>: Will be assigned to the virtual <tt>draw()</tt>
    method of the base class. The 3 other functions are for handling mouse clicks. A BgrWin can be made movable
    if these functions are assigned to <tt>mwin::down</tt>, <tt>mwin::move</tt>, <tt>mwin::up</tt> respectively
    (where <tt>mwin</tt> is a namespace). See method <tt>keep_on_top()</tt>.
</dd>
<dt>void (*display_cmd)(BgrWin*)<dd>
  This function, assigned to the class <tt>draw()</tt> method, will be called (if it is non-zero) with as
  parameter the value of <tt>this</tt>, so you can investigate e.g. the background color of the BgrWin.</dd>
<dt>void (*down_cmd)(BgrWin*,int x,int y,int but)<dd>
  This function is called if the mouse is clicked. As usual, the <tt>id</tt> value of the BgrWin 
  can be used to find out in which widget the mouse was clicked.
  Thus, all BgrWin's can use the same callback function,
  which usually will start with a <tt>switch</tt> statement.</dd>
<dt>void (*moved_cmd)(BgrWin*,int x,int y,int but)<dd>
  The function that is called repeatedly when the mouse is moving. NB! In order to prevent a big number
  of useless motion events, standard the statement
  <tt>SDL_EventState(SDL_MOUSEMOTION,SDL_IGNORE)</tt> is active, so motion events will <b>not</b>
  be transferred. Therefore you should enable them yourself inside the <tt>down_cmd</tt> function.</dd>
<dt>void (*up_cmd)(BgrWin*,int x,int y,int but)<dd>
  The function called when the mouse is released. The mouse motion events will be disabled again.
</dl>
</tr>

<tr>
<td class="bold">Button:WinBase</td>
<td>A push button.
<dl>
<dt>Button(WinBase *pw,Style st,Rect rect,Label lab,void (*cmd)(Button*),Id id=0)<dd>
  The constructor.
  </dd>
<dt>bool is_down<dd>
  The state of the button.</dd>
<dt>Style style<dd>
  5 styles are implemented, three of them to be used for the label of a CmdMenu widget.</dd>
<dt>Label label<dd>See above.</dd>
<dt>void (*cmd)(Button*)<dd>
  The function to call when the button is clicked. This happens before the draw() command is called,
  so the label of the button can be modified by the function. A Button has no callback
  function for mouse release.</dd>
</dl>

<tr>
<td class="bold">HSlider:WinBase</td>
<td>A horizontal slider. The most important variables and methods:
<dl>
<dt>HSlider(WinBase *parent,Style st,Rect rect,int minval,int maxval,<br>
  &emsp;const char* title,void (*cmd)(HSlider*,int fire,bool rel),Id id=0)<dd>
  <tt>rect.h</tt> can be 0, a default height is used.<br>
  <tt>cmd()</tt> specifies the callback function, that is also responsible for the text
  that shows the value of the slider.</dd>
<dt>int def_data<br>int *d</dt><dd>
  The actual value for a slider is stored in an integer, via pointer <tt>d</tt>, in order to facilitate that different
  sliders share the same data, or that one slider has several tasks.
  In the default case its own <tt>def_data</tt> is used. See the
  <a href="#cookbook"><b>Cookbook</b></a> chapter.</dd>
<dt>char *text<dd>
  The text indicating the slider value. Usually this text is set by global function <tt>set_text()</tt>,
  so informative text can be created if needed.
<dt>Style style<dd>
  Two styles are available. The small white lines indicating the possible positions of the slider knob
  are left out if <tt>style.param</tt> is non 0.</dd>
<dt>void (*cmd)(HSlider*,int fire,bool rel)<dd>
  The function that is called when the slider knob has been moved (then <tt>rel</tt> is <tt>false</tt>) or
  if the mouse button has been released (then <tt>rel</tt> is <tt>true</tt>). This function also can be used from other
  places in your program. In this case the parameter <tt>fire</tt> can be used to convey extra information (its
  value is 1 if called by the slider itself).</dd>
<dt>int &value()<dd>
  For setting and getting the slider value.</dd>
<dt>void set_hsval(int val,int fire,bool do_draw=true)<dd>
  A method to set the slider value. If <tt>fire</tt> is non-zero, then <tt>cmd</tt> is called with
  appropriate parameters. If <tt>do_draw</tt> is true, then the slider will be redrawn.</dd>
</dl>
</tr>

<tr>
<td class="bold">VSlider:WinBase</td>
<td>A vertical slider, similar to HSlider.
<dl>
<dt>VSlider(WinBase *parent,Style st,Rect rect,int minval,int maxval,<br>
    &emsp;const char* title,<br>
    &emsp;void (*cmd)(HSlider*,int fire,bool rel),Id id=0)<dd>
  <tt>rect.w</tt> can be 0, a default width will be used. The text of the slider value will be drawn
  directly to the parent widget.</dd>
</dl>
</tr>

<tr>
<td class="bold">HVSlider:WinBase</td>
<td>A 2-dimensional slider. The values are specified with a struct:
  <tt>Int2 { int x, y; }</tt>
<dl>
  <dt>HVSlider(WinBase *parent,Style st,Rect rect,Int2 minval,Int2 maxval,<br>
     &emsp;const char* title,<br>
     &emsp;void (*cmd)(HVSlider*,int fire,bool rel),Id id=0)<dd></dd>
</dl>
</td>

<tr>
<td class="bold">Dial:WinBase</td>
<td>A dial with characteristics similar to the sliders. Control with the mouse is in the
horizontal direction, as this is faster then moving the mouse in a circular way.
<dl>
<dt>Dial(WinBase *pw,Style st,Rect rect,int minval,int maxval,<br>
    &emsp;const char* title,void (*cmd)(Dial*,int fire,bool rel),Id id=0)<dd>
  The height of the rectangle, <tt>rect.h</tt> is don't care, the widget is square
  always.</dd>
</dl>
</tr>

</tr>

<tr>
<td class="bold">CheckBox:WinBase</td>
<td>A checkbox button.
<dl>
<dt>CheckBox(WinBase *pw,Style,Rect,Label lab,void (*cmd)(CheckBox*),Id id=0)<dd>
The constructor. Two styles available.</dd>
<dt>bool def_val<br>bool *d<dd>
The actual value for a checkbox can be stored in a separate bool.
In the default case its own <tt>def_val</tt> is used, via pointer <tt>d</tt>.
<dt>bool &value()<dd>
Dereferencing <tt>d</tt>.</dd>
<dt>void (*cmd)(CheckBox*)<dd>
  Called when clicked.</dd>
<dt>void set_cbval(bool,int fire,bool do_draw=true)<dd>
  A method to set the checkbox value. If <tt>fire</tt> is non-zero, then <tt>cmd</tt> is called with
  appropriate parameters. If <tt>do_draw</tt> is true, then the checkbox will be redrawn.</dd>
</dl>
</tr>

<tr>
<td class="bold">RButWin:WinBase</td>
<td>
  A group of radio buttons, of class RButton. Only one of them can be active. This widget has
  many features.
<dl>
<dt>RButWin(WinBase *parent,Style st,Rect rect,const char *title,bool maybe_z,<br>
    &emsp;void(*rb_cmd)(RButWin*,int nr,int fire),Id id=0)<dd>
  The constructor.</dd>
<dt>RButton *act_button<dd>
  A pointer to the active button.
<dt>bool maybe_z<dd>
  If true, then a second mouse click on the active button has the effect that no button will be active.</dd>
<dt>RButWinData def_buttons,<br>RButWinData *buttons<dd>
  The actual button data can be stored in a separate structure.
  In the default case <tt>buttons</tt> is pointing to the built-in <tt>def_buttons</tt>.</dd>
<dt>Style style<dd>
  Two styles are provided: one with a list of button names (one of them highlighted), and one with
  tick widgets. Some extra styles are used for menu buttons.</dd>
<dt>void (*rb_cmd)(RButWin*,int nr,int fire)<dd>
  This function is called if a button is clicked.
  <tt>nr</tt> is the number of the clicked button, starting from zero for the first button. <tt>fire</tt>
  has value 1 if the clicked button is different from the previous button, else 0.
  The <tt>fire</tt> value can be used as extra information if this function is called from another place in
  your program.</dd>
<dt>RButton *add_rbut(Label label)<dd>
  Adds a button. Radio buttons will have a number, starting from 0. <tt>label</tt> is a struct as described
  before.</dd>
<dt>void set_rbut(RButton *rb,int fire,bool do_draw=true)<dd>
  Set the active button. If <tt>fire</tt> is non-zero, then <tt>rb_cmd</tt> will be called.
  If <tt>do_draw</tt> is true, the button will be redrawn.</dd>
<dt>void set_rbutnr(int nr,int fire,bool do_draw=true)<dd>
  Similar, the desired button specified as a number.</dd>
<dt>int act_rbutnr()<dd>
  Returns the active button as a number. If none is active, then -1 is returned.</dd>
<dt>void reset()<dd>
  Remove all buttons.</dd>
</dl>
</tr>

<tr>
<td class="bold">ExtRButCtrl</td>
<td>This is the control part of one group of radio buttens of class RExtButton:WinBase, that each can
  be placed where you want them.
<dl>
<dt>ExtRButCtrl(Style st,void (*cmd)(RExtButton*,bool is_act))<dd>
  Notice that the constructor does'nt have a <tt>WinBase *parent</tt> parameter, because it's not
  a widget. The <tt>st</tt> style parameter is copied to the RExtButton's.</dd>
<dt>int butnr<dd>
  The number of the last added RExtButton.</dd>
<dt>bool maybe_z<dd>
  If set to true, then a second mouse click on the active button has the effect that no button will be active.</dd>
<dt>void (*reb_cmd)(RExtButton*,bool is_act)<dd>
  This function will be called if a button is clicked, in this case <tt>is_act</tt> will be true.
  If <tt>maybe_z</tt> has been set to true and the button is clicked again, then the function is called
  again, with parameter <tt>is_act</tt> false.</dd>
<dt>set_rbut(RExtButton* rb,int fire)<dd>
  Set the active button.</dd>
<dt>void reset()<dd>
  None of the radio buttons will be active.</dd>
</dl>
</tr>

<tr>
<td class="bold">RExtButton:WinBase</td>
<td>One of the radio buttens that are controlled by a ExtRButCtrl.
<dl>
<dt>RExtButton(WinBase *pw,Style st,Rect rect,Label lab,Id id=0)<dd>
  <tt>rect.h</tt> and/or <tt>rect.w</tt> may be 0, they will get a default value.</dd>
<dt>ExtRButCtrl *rxb_ctr<dd>
  A pointer to the ExtRButCtrl.</dd>
<dt>Style style<dd>
  3 styles are provided. Two of them are especially fit for creating tab-controlled windows.</dd>
</dl>
</tr>

<tr>
<td class="bold">TextWin:WinBase</td>
<td>A non-editable text window. If a new text line is inserted and the window was full, then all
  lines will be shifted 1 place upward. The lines will be written at a distance TDIST (= 14) pixels.
<dl>
<dt>TextWin(WinBase *pw,Style,Rect rect,int lmax,const char* title,Id id=0)<dd>
  <tt>rect.h</tt> may be 0, it will get a height sufficient to contain <tt>lmax</tt> text lines.<br>
  2 styles are provided.</dd>
<dt>int lmax<dd>
  The maximum number of text lines before scrolling upwards will occur.</dd>
<dt>char (*textbuf)[100]<dd>
  The lines are stored as strings.</dd>
<dt>void add_text(const char* txt,bool do_draw)<dd>
  Add a text line. The <tt>txt</tt> string may contain '\n' (newline).
  If <tt>do_draw</tt> is true, then the complete TextWin will be drawn and updated.</dd>
</dl>
</tr>

<tr>
<td class="bold">HScrollbar:WinBase</td>
<td>A horizontal scrollbar.
<dl>
<dt>HScrollbar(WinBase *pw,Style st,Rect,int range,void (*cmd)(HScrollbar*,int val,int range),Id id=0)<dd>
  The constructor.</dd>
<dt>Style style<dd>
  There are 2 styles: without and with 2 small buttons for repeating single-step operation when the mouse
  button is kept down. The step value is set by st.param2</dd>
<dt>int range<dd>
  In general the width of a scrollbar is choosen equal to the width of the window that is controlled by the
  scrollbar. Then <tt>range</tt> is the width of a bigger window that can be made visible if the scrollbar knob
  is moved.</dd>
<dt>void (*cmd)(HScrollbar*,int val,int range)<dd>
  This function will be called if the scrollbar knob is moved. Normally this function should set
  some variable that controls which part of a bigger, virtual window has to be be drawn, and then call
  the drawing function of this window.</dd>
<dt>void set_range(int range)<dd>Suppose that an actual window and its scrollbar have the same width,
  and a virtual window with width 200
  must be made visible. Then <tt>set_range(200)</tt> would be appropriate.</dd>
</dl>
</tr>

<tr>
<td class="bold">VScrollbar:WinBase</td>
<td>A vertical scrollbar, similar to HScrollbar.</td>
</tr>

<tr>
<td class="bold">DialogWin:WinBase</td>
<td>A dialog widget, containing an editable text area. It can be edited after a mouse click in
  this area. A cursor will be shown then, which can be moved with the left and right arrow keys.
  The only special key is <tt>&lt;ctrl>d</tt>, which will clear the text line. If entered text is too long for the
  text area, then the line is shifted to the left.
<dl>
  <dt>DialogWin(WinBase *pw,Rect rect,Id id)<dd>
    <tt>rect.h</tt> may be 0, the height is always 2*TDIST.</dd>
  <dt>const char *label<dd>
    The label above the text area. It is assigned by method dialog_label().</dd>
  <dt>int cmd_id<dd>
    Used as a parameter for the callback function.</dd>
  <dt>void (*cmd)(const char* text,int cmd_id)<dd>
    This callback function must be assigned by the user. It will be called when you hit enter,
    <tt>text</tt> will be the text from the text area.</dd>
  <dt>void dialog_label(const char *s,Uint32 col=0)<dd>
    Method to set the label. If <tt>col</tt> is non-zero then it will be used as background color
    for the label text, e.g. to highlight it if user input is expected.</dd>
  <dt>void dialog_def(const char *str,void(*cmd)(const char* text,int cmd_id),int cmd_id)<dd>
    This method sets the default text for the text area, assigns <tt>cmd()</tt>
    and <tt>cmd_id</tt>.
    </dd>
  <dt>void dok()<dd>
    Data-okay: intended to be used by other widgets. It calls <tt>cmd()</tt> with the current text string.</dd>
</dl>
</tr>
<tr>
<td class="bold">CmdMenu</td>
<td>A menu widget.
<dl>
  <dt>CmdMenu(Button *src)<dd>
    CmdMenu itself is not really a widget, the work is done by a Button and a RButWin. The Button <tt>src</tt>
    should have a <tt>cmd</tt> that initializes the menu by calling first member function <tt>init()</tt>,
    and then several times <tt>add_mbut()</tt> in order to add the menu buttons.</dd>
  <dt>bool init(int wid,int nr_buttons,void (*menu_cmd)(Id id,int nr,int fire))<dd>
    <tt>wid</tt> will be the width of the menu. <tt>nr_buttons</tt> sets the number of menu buttons.
    This function will create a RButWin whose member <tt>rb_cmd()</tt> will have the value of parameter
    <tt>menu_cmd()</tt>. When the user clicks a menu button, then <tt>menu_cmd()</tt> will be called.
    Then parameter <tt>nr</tt> is equal to the sequence number of the menu button, and <tt>id</tt> is
    equal to the <tt>id</tt> of Button <tt>src</tt> of the constructor.</dd>
  <dt>void add_mbut(const char *txt)<dd>
    Each call if this function will create a menu button. If it has been called <tt>nr_buttons</tt> times,
    then the actual menu will be created and blitted to the screen. When the user has clicked one
    of the menu buttons, then <tt>menu_cmd()</tt> is executed. If this function calls <tt>close()</tt>
    then the menu will disappear.</dd>
  <dt>bool sticky<dd>
    If true, then the menu will stay visible after it has been clicked. This variable should be
    controlled by another widget or by the program, not by it's own menu command.</dd>
  <dt>void mclose()<dd>
    To close the menu (which actually is a BgrWin widget). Not to be used in your code: menu's are closed
    automatically, unless <b>sticky</b> is true.</dd>
</dl>
If you think that a menu widget is somewhat complicated then you are right. Look for an example in
the demo program (testsw.cpp).
</tr>
<tr>
<td class="bold">EditWin:WinBase</td>
<td>A simple text editor. The arrow keys, the backspace key and the enter keys work as
    expected. Long lines are supported. A whole line can be deleted with <tt>&lt;ctrl>d</tt>.
    <p>
    This widget might also be useful as a convenient text buffer, as all memory allocation
    goes automatic. The methods that are of interest for the user are as follows.
<dl>
<dt><div>
EditWin(WinBase *pw,Rect rect,const char *title,<br>
  &emsp;void (*cmd)(int ctrl_key,int key,int cmd_id),Id id=0)
</div>
<dd>
The constructor. <tt>(*cmd)()</tt> specifies a callback function that will be called at each key stroke.</dd>
<dt>void set_line(int n,bool upd,const char *form,...)
<dd>A printf-like method to assign line number <tt>n</tt>.</dd>
<dt>void insert_line(int n,bool upd,const char *form,...)
<dd>Similar, but following lines will be shifted one position.</dd>
<dt>const char *get_line(int n)
<dd>Returns a pointer to the data at line <tt>n</tt>.
<dt>void get_info(bool *active,int *nr_of_lines,int *cursor_pos,int *nr_chars,int *total_nr_chars)
<dd>To get information about the stored data. The pointers can be zero.</dd>
<dt>Line **lines
<dd>A buffer containing pointers to struct's of type <tt>Line</tt> that also is used by <tt>DialogWin</tt>.
Notice that a pointer is zero in case of an empty line.
<dt>int linenr
<dd>The buffer index of the last line.</dd>
<dt>int y_off
<dd>Rendering of text will start at pixel number <tt>y_off</tt>. Normally this variable
will be set by a vertical scrollbar.<dd>
</dl>
</tr>

<tr>
<td class="bold">RenderText</td>
<td>A class to draw ascii text to an SDL_Surface. Each font needs one instance of this class.
  3 fonts are provided:<br>
  <tt>RenderText *draw_title_ttf</tt>, which is TrueType font FreeSans, pointsize 13, color darkblue, used for titles.<br>
  <tt>RenderText *draw_mono_ttf</tt>, font FreeMono, pointsize 12, regular, for editable text.<br>
  <tt>RenderText *draw_ttf</tt>, font FreeSans, pointsize 12, regular, for everything else.
<dl>
<dt>RenderText(TTF_Font *font,SDL_Color tcol)<dd>
  The constructor. For <tt>font</tt> you could use e.g. <tt>draw_ttf->ttf_font</tt>. To get a font of different
  size, TTF_OpenFont() has to be called. A global <tt>const char* def_fontpath</tt> is provided, it is equal
  to the file that's used for <tt>draw_ttf</tt>.</dd>
<dt>TTF_Font *ttf_font<dd>
  The font, created with TTF_OpenFont()<dd>
<dt>SDL_Color text_col<dd>
  The font color.
<dt>SDL_Surface *chars[]<dd>
  Not of interest for the user. All characters of the alphabet are blitted here when they are used
  for the first time, calling TTF_RenderText_Blended() from the SDL_ttf library.</dd>
<dt>int draw_string(SDL_Surface *win,const char *txt,Point point)<dd>
  Will blit the characters of <tt>txt</tt> to the appropriate place of <tt>win</tt>, taking them from surface <tt>chars[]</tt>.
  The place where you want them is set by parameter <tt>point</tt>. Newlines (character '\n') are supported,
  they will be blitted on a new line. This method returns the value of variable <tt>y</tt> of a Point that
  could be used with the next call of <tt>draw_string</tt>.</dd>
<dt>int text_width(const char *txt)<dd>
  Returns the width of the text after rendering.</dd>
</dl>
</tr>

<tr>
<td class="bold">Lamp</td>
<td>A status indicator.
<dl>
<dt>Lamp(WinBase *pw,Rect rect)<dd>
  The constructor. Only <tt>rect.x</tt> and <tt>rect.y</tt> are used, they set the upper left corner of the lamp.</dd>
<dt>void draw()<dd>
  A Lamp is <i>not</i> a WinBase, and <i>not</i> incorporated in the SDL_Surface hierarchy. Normally you
  must call this <tt>draw()</tt> method inside the <tt>display_cmd()</tt> of the BgrWin that contains the lamp,
  in order to make it visible at startup.</dd>
<dt>void set_color(Uint32 col)<dd>
  The indicator will be drawn with color <tt>col</tt>, which
  must be in the format 0xRRGGBBAA (as needed by the SDL_gfx library),
  e.g.: <tt>0xff00ff</tt> (the color green, opaque).
</dl>
</td>
</tr>
<td class="bold">Message</td>
<td>A fixed label plus a variable text.
<dl>
<dt>Message(WinBase *pw,Style style,const char* label,Point top)<dd>
  <tt>top</tt> is the left upper corner of the label.</dd>
<dt>const char *label<dd>The fixed label.</dd>
<dt>void draw_label()<dd>
  To draw and blit the label.</dd>
<dt>void draw_mes(const char *form,...)<dd>
  To draw, blit and update the variable text. Formatted parameters like printf().</dd>
<dt>Style style<dd>
  If style.st = 0, then no border around the variable text. If style.st = 1, then a 3D-effect border.
  If style.st = 2, then a dark line. If style.param is non-zero, then its value will be used as a
  background color</dd>
<dt>Uint32 bgcol<dd>
  The background color for the variable text, default equal to the color of the parent surface.</dd>
</dl>
</table>

<h2>Global variables</h2>
<table>
<tr><td>
<dl>
<dt>bool sdl_running<dd>
Will be true after execution of the first statement of <tt>get_events()</tt>. If <tt>sdl_running</tt>
is still false, drawing to the screen is not useful (though it's not forbidden).</tt>
<dt>RenderText *draw_ttf, *draw_title_ttf, *draw_mono_ttf<dd>
Text fonts.</dd>
<dt>const char *def_fontpath<dd>
The filename that's used for <tt>draw_ttf</tt>.
<dt>Uint32 cWhite, cBlack, cGrey, cRed, cBlue, cForeground, cBackground, cBorder, cPointer, cScrollbar<dd>
Predefined colors for SDL_Surface's. These can be modified if needed, using <tt>calc_color()</tt></dd>
<dt>SDL_Color def_text_col<dd>
The text color (black).</dd>
<dt>Point alert_position<dd>The left-upper corner of the alert window. Default is (4,4).
</dl>
</table>

<h2>Global functions</h2>
<table>
<tr><td>
<dl>
<dt>void get_events()<dd>
After you have specified all your widgets this function should be called. It starts with
a <tt>draw_blit_recur()</tt> of the top widget, as returned from <tt>new TopWin()</tt>. Then it enters
an infinite loop, waiting for mouse clicks and keystrokes.
Also a built-in queue for
user events (originating from function <tt>send_uev</tt>) is polled.</dd>
<dt>void send_uev(int cmd,int param1=0,int param2=0)<dd>
As mentioned in the introduction, threads can communicate with the main thread using messages.
Locking of the main thread is not needed, the toolkit will do it for you. A message has 3 fields
of type int, where the first one normally is used as a key, the others as parameters. So,
if a thread wants to perform some graphics, then first set the appropriate data, and subsequently
send a message, e.g: <tt>send_uev('doit');</tt><br>
The intern message queue has a default length 50. If it has to grow, then a warning is sent to stdout. This
is harmless, but possibly there is some issue in your code.</dd>
<dt>void (*handle_uev)(int cmd,int param,int param2)<dd>
This function pointer should be assigned to a function of the same type, in which you
specify what must be done after receiving a user event. If you do not assign it, a built-in default
function will be called (which only sends some text to stdout)</dd>
<dt>void alert(const char *form,...)<dd>
An alert window will appear, which can be moved with the mouse.
The parameters are the same as for printf. Great care has been taken to guarantee that
this function can be called in every state that a running program is in. If a topwindow
has not yet been created, then the alert message will be written to stdout.</dd>
<dt>Uint32 calc_color(Uint32 c)<dd>
Translates a color in RGB format (like: 0xf0f0f0) to a value usable for SDL_Surface's.
Must be called after the top window has been instantiated. Several colors are already available,
see header file sdl-widgets.h.
<dt>void set_text(char *&txt,const char *fs,...)<dd>
This printf-like function is used most often to set the text at sliders. If <tt>txt</tt> is zero,
then it will be allocated. No actual drawing will be done.</dd>
<dt>Rect *rp(int x,int y,int w,int h)<dd>
This is a convenience function: to create a SDL_Surface you always need a pointer to a
rectangle (Rect is actually a subclass of SDL_Rect). This function creates one, 
however notice that it's always the same Rect.<br>
Also notice that this function is specified in header file sdl-widgets.h, so each source file will get
its own instance.
<dt>SDL_Surface *create_pixmap(const char* pm_data[])<dd>
For small icons the X-Windows XPM format is ideal, because the pixmap data is normal C code
and thus can be included in your source code. Pixmaps can be created e.g. with the tool xpaint.<br>
The colors in the pixmap look like #606060 (this is light grey).
The function makes black pixels (color: #0 or: <tt>None</tt>) translucent.
</dd>
<dt>SDL_Cursor *init_system_cursor(const char *image[])<dd>
The standard SDL cursor is black with a white border, which is not very convenient for white backgrounds.
This function can create an SDL_cursor of 32x32 pixels usable by SDL_SetCursor(). The <tt>image</tt> 
parameter is a normal XPM struct,
with an added last line for the hot spot. The code for <tt>init_system_cursor</tt> is borrowed from the
SDL distribution, modified such that <tt>image</tt> data may be smaller then 32x32. See file pixmaps.h for
an example.
</dd>
<dt>void file_chooser(void (*cmd)(const char* f_name,Id id),Id id=0)<dd>
To choose a file. If called, then a temporary window will pop up, showing the contents of
the current directory: directories (in blue color), 
files (in black), links (in black, with '<tt>@</tt>' added).
If a directory name is clicked, then the current
directory will become equal to this directory, whose contents now will be shown. If a file name is clicked,
then the pop-up window will be hidden and <tt>cmd()</tt> will be called (if it's non-zero).<br>
You can use <tt>id</tt> if the function is called multiple times. The name of the current directory
always will be shown in the banner of your window manager.
</dd>
<dt>void working_dir(void (*cmd)(const char* dir_name,Id id),Id id=0)
<dd>
To choose a new working directory. If called, then a temporary window will pop up, showing the directories
present in the current directory. If a directory name is clicked, then the current
directory will become equal to this directory,
then the pop-up window will be hidden and <tt>cmd()</tt> will be called (if non-zero).</dd>
<dt>void print_h()
<dd>Print the full widget hierarchy and the (temporary) on-top widgets to the screen. Useful for debugging.
</dl>
</td>
</tr>
</table>
<h2>Hello World</h2>
<table>
<tr><td>
<pre>
#include &lt;sdl-widgets.h&gt;

TopWin *top_win;
Button *but;

void topw_disp() {
  top_win->clear();
  draw_title_ttf->draw_string(top_win->win,"Hello world!",Point(20,40));
}

void button_cmd(Button*) {
  top_win->clear(but->tw_area,cBackground,true);
  static int y=10;
  y= y==10 ? 70 : 10;
  but->area.y=but->tw_area.y=y;
}

int main(int ac,char** av) {
  top_win=new TopWin("Hello",Rect(100,100,120,100),SDL_INIT_VIDEO,0,topw_disp);
  but=new Button(top_win,0,Rect(5,10,60,0),"catch me!",button_cmd);
  get_events();
  return 0;
}
</pre>
</td></table>
This can be compiled with<br>
<tt>   g++ hello.cpp sdl-widgets.o -o hello -lSDL -lSDL_gfx -lSDL_ttf</tt>
<p>
As an extra bonus there is a button that will move if you click it.
<p>
<a name="cookbook">
<h2>Cookbook for less-trivial applications</h2></a>
Most people seem to be focused on the "looks" of a GUI, however if you ever wrote
a not-so-simple application you'll have perceived that this part belongs to the minor problems.
The difficult part is the initialization of all the widgets in the right order, the interaction between them, and
also to make the application fool-proof: an unexpected user action should result in a neat warning,
not in a crash. At that it would be convenient that code is not replicated inside the program
in order to make maintenance easier. This implies e.g. that the callback function of
a widget could be called from other places, during initialization or from the callback
functions of other widgets.
<p>
The first choice: should widgets and other objects be on the stack or on the heap?
A simple rule is: <i>if</i> the initialisation of an object does not depend on other objects,
<i>or</i> if that other objects are coded in the same file, <i>then</i> they can be on the stack. In
all other cases use the heap, allocating pointers in the right order with <tt>new</tt>.
<p>
<h4>The main() function</h4>
After evaluation of the arguments issued by the user, the first thing you do is to
create a top window. After this e.g. new colors can be created. From now on, alert
messages will be displayed in a small subwindow.
<p>
Then if needed an initialization file can be read. If this may affect the properties
of widgets, then remember that these widgets have not been initialized yet. In general
it is convenient to read a config file as late as possible.
<p>
Now is the time to create all widgets. For widgets that should be invisible set the
<tt>hidden</tt> variable to <tt>true</tt>. The <tt>draw()</tt> member function should 
not be called, this is done automatically after <tt>get_events()</tt>.
<p>
A widget may have a complicated callback
function and it can be very handy to call this function after the widget's creation, e.g.
to set the proper text for the widget. As an
example, a horizontal slider (class HSlider) has a member function
<tt>void set_hsval(int val,int fire,bool do_draw=true)</tt>. If <tt>fire</tt> is
non-zero, then the callback function of the slider will be executed.
Parameter <tt>do_draw</tt> must be false in this stadium, or be assigned to <tt>sdl_running</tt>
which is false before <tt>get_events()</tt> has been called and true thereafter.
<p>
After all widgets have been instantiated, call <tt>get_events()</tt>. The first statement of this 
function is a <tt>draw_blit_recur()</tt>
of the top window, which will draw everything recursively. Now the program will start waiting
for your mouseclicks and keystrokes.

<h4>Callback functions</h4>
These are global functions or static member functions. Each callback function has a parameter of class Id, which
can be used to investigate from which widget the callback originated. An alternative is
to give each callback function a unique name. Notice that a callback function has a
parameter list depending on the widget class, and that pointer cast's are never needed.

<h4>Where to store the widget values?</h4>
All widgets contain a pointer called <tt>d</tt> which by default points to a class variable.
If you want to use the same data for different widgets, then use an external variable of the right type,
and set the <tt>d</tt>'s to point to that variable. Also the opposite is possible: one widget could
be attached to different data, which often happens in case of tabbed subwindows. Then, if a tab is clicked
only the <tt>d</tt>'s of the widgets on the subwindow have to be re-assigned, and the widgets re-drawn
(with <tt>draw_blit_upd()</tt>.

<h4>Threads</h4>
If a thread other then the main thread wants to write to the screen,
it should not do this directly. Instead it has to send a message using the <tt>send_uev()</tt>
function, after it has set all concerning values. The sent messages are queued automatically 
and then handled by <tt>handle_uev()</tt>
which you have supplied. This function will run in the main thread and may draw to the screen safely.
<p>
<hr/>
</body>
</html>
